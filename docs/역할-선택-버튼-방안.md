# 역할 선택 버튼 방안 분석

## 제안된 방안
**메인 페이지(홈 화면)에서 "보호자" / "보호대상자" 구분 버튼으로 사용 화면을 선택**

---

## 방안 개요

### UI 구조
```
홈 화면 (메인 페이지)
  ├─ [보호대상자 모드] 버튼 (큰 버튼)
  │   └─ 상태 알려주기 화면
  │   └─ 보호자 지정 화면
  │
  └─ [보호자 모드] 버튼 (큰 버튼)
      └─ 보호 대상 확인 화면
      └─ 보호 대상 목록
```

### 사용 흐름
1. 앱 실행 → 홈 화면
2. 사용자가 "보호대상자 모드" 또는 "보호자 모드" 선택
3. 선택한 모드에 맞는 화면으로 이동
4. 다음 실행 시에도 동일한 선택 가능 (또는 마지막 선택 기억)

---

## 장점 ✅

### 1. 명확한 역할 구분
- ✅ 사용자가 자신의 역할을 명확히 인지
- ✅ UI가 단순하고 직관적
- ✅ 혼란 없음 ("지금 뭘 해야 하지?" 없음)

### 2. 유연성
- ✅ 한 사람이 둘 다 역할을 할 수 있음 (매번 선택)
- ✅ 역할 전환이 쉬움 (홈으로 돌아가서 다시 선택)
- ✅ 별도의 역할 감지 로직 불필요

### 3. 사용자 제어
- ✅ 사용자가 원하는 모드를 직접 선택
- ✅ 자동 감지 오류 가능성 없음
- ✅ 예상 가능한 동작

### 4. 구현 단순성
- ✅ 복잡한 역할 감지 로직 불필요
- ✅ Firestore 쿼리 최소화
- ✅ 빠른 개발 가능

---

## 단점 ⚠️

### 1. 매번 선택 필요
- ⚠️ 앱 실행할 때마다 선택해야 함 (불편할 수 있음)
- ⚠️ 자주 사용하는 모드가 있으면 번거로움

### 2. 사용자 혼란 가능성
- ⚠️ "둘 다 해야 하는데 어떻게 하지?" (두 번 왔다갔다)
- ⚠️ 초기 사용자가 어떤 모드를 선택해야 할지 모를 수 있음

### 3. UX 흐름
- ⚠️ 홈 화면에서 한 단계 더 거쳐야 함
- ⚠️ 빠른 접근이 필요한 경우 (알림 클릭 등) 흐름이 끊김

---

## 개선 방안

### 개선 1: 마지막 선택 기억 (권장) ⭐

**로직:**
- SharedPreferences 또는 Firestore에 마지막 선택한 모드 저장
- 다음 실행 시 자동으로 해당 모드로 진입
- 필요 시 홈 화면에서 모드 변경 가능

**장점:**
- ✅ 자주 사용하는 모드 자동 선택
- ✅ 사용자 편의성 향상
- ✅ 여전히 모드 전환 가능

**구현:**
```dart
// SharedPreferences 사용
final prefs = await SharedPreferences.getInstance();
final lastMode = prefs.getString('last_selected_mode') ?? 'subject';

// 또는 Firestore users 문서에 저장
await firestore.collection('users').doc(uid).update({
  'preferredMode': 'subject', // 또는 'guardian'
});
```

---

### 개선 2: 빠른 접근 버튼

**UI 구조:**
```
홈 화면
  ├─ [보호대상자 모드] (큰 버튼)
  ├─ [보호자 모드] (큰 버튼)
  └─ [빠른 접근] (작은 버튼)
      ├─ 상태 알려주기 (보호대상자)
      └─ 보호 대상 확인 (보호자)
```

**장점:**
- ✅ 자주 사용하는 기능 빠른 접근
- ✅ 모드 선택 없이도 주요 기능 사용 가능

---

### 개선 3: 알림 클릭 시 자동 모드 선택

**로직:**
- 알림 클릭 시 역할에 맞는 모드로 자동 진입
- 보호 대상자 알림 → 보호대상자 모드
- 보호자 알림 → 보호자 모드

**장점:**
- ✅ 알림 흐름이 자연스러움
- ✅ 사용자가 모드를 선택할 필요 없음

---

## 구현 예시

### 홈 화면 구조

```dart
class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  String? _selectedMode; // 'subject' 또는 'guardian'

  @override
  void initState() {
    super.initState();
    _loadLastSelectedMode();
  }

  Future<void> _loadLastSelectedMode() async {
    final prefs = await SharedPreferences.getInstance();
    final lastMode = prefs.getString('last_selected_mode');
    if (lastMode != null && mounted) {
      setState(() {
        _selectedMode = lastMode;
      });
      // 자동으로 해당 모드로 진입 (선택적)
      // _navigateToMode(lastMode);
    }
  }

  Future<void> _selectMode(String mode) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('last_selected_mode', mode);
    
    setState(() {
      _selectedMode = mode;
    });
    
    _navigateToMode(mode);
  }

  void _navigateToMode(String mode) {
    if (mode == 'subject') {
      // 보호대상자 모드로 진입
      Navigator.pushReplacement(
        context,
        MaterialPageRoute(builder: (_) => const SubjectModeScreen()),
      );
    } else if (mode == 'guardian') {
      // 보호자 모드로 진입
      Navigator.pushReplacement(
        context,
        MaterialPageRoute(builder: (_) => const GuardianModeScreen()),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const AppLogo(...),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Text(
              '어떤 모드로 사용하시겠어요?',
              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 48),
            
            // 보호대상자 모드 버튼
            SizedBox(
              width: double.infinity,
              height: 120,
              child: FilledButton.icon(
                onPressed: () => _selectMode('subject'),
                icon: const Icon(Icons.person, size: 48),
                label: const Column(
                  children: [
                    Text('보호대상자 모드', style: TextStyle(fontSize: 20)),
                    SizedBox(height: 4),
                    Text('상태를 알려주는 모드', style: TextStyle(fontSize: 14)),
                  ],
                ),
                style: FilledButton.styleFrom(
                  padding: const EdgeInsets.all(24),
                ),
              ),
            ),
            
            const SizedBox(height: 24),
            
            // 보호자 모드 버튼
            SizedBox(
              width: double.infinity,
              height: 120,
              child: FilledButton.icon(
                onPressed: () => _selectMode('guardian'),
                icon: const Icon(Icons.visibility, size: 48),
                label: const Column(
                  children: [
                    Text('보호자 모드', style: TextStyle(fontSize: 20)),
                    SizedBox(height: 4),
                    Text('보호 대상을 확인하는 모드', style: TextStyle(fontSize: 14)),
                  ],
                ),
                style: FilledButton.styleFrom(
                  padding: const EdgeInsets.all(24),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

---

## 다른 방안과의 비교

| 항목 | 자동 감지 | 선택 버튼 | 초기 설정 |
|------|----------|----------|----------|
| 사용자 편의성 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| 명확성 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 구현 복잡도 | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 역할 전환 | 자동 | 수동 (쉬움) | 설정에서 변경 |
| 초기 설정 필요 | 없음 | 없음 | 필요 |

---

## 최종 의견

### ✅ 이 방안이 적합한 경우

1. **명확한 역할 구분이 중요한 경우**
   - 사용자가 자신의 역할을 명확히 인지해야 함
   - 혼란을 최소화하고 싶음

2. **사용자가 둘 다 역할을 하는 경우가 많은 경우**
   - 부모가 자녀를 보호하면서, 자신도 보호 대상자인 경우
   - 역할 전환이 자주 필요함

3. **빠른 프로토타입 개발**
   - 복잡한 로직 없이 빠르게 구현 가능
   - 나중에 개선 가능

### ⚠️ 주의사항

1. **마지막 선택 기억 기능 필수**
   - 매번 선택하는 것은 불편함
   - SharedPreferences로 저장 필요

2. **알림 클릭 시 자동 모드 선택**
   - 알림에서 앱 진입 시 역할에 맞는 모드로 자동 이동
   - 사용자 경험 개선

3. **빠른 접근 기능 고려**
   - 자주 사용하는 기능은 바로 접근 가능하도록

---

## 권장 구현 방안

### 단계별 구현

**1단계: 기본 선택 버튼**
- 홈 화면에 두 개의 큰 버튼
- 선택 시 해당 모드 화면으로 이동

**2단계: 마지막 선택 기억**
- SharedPreferences로 마지막 선택 저장
- 다음 실행 시 자동 선택 (또는 자동 진입)

**3단계: 알림 클릭 시 자동 모드 선택**
- 알림에서 진입 시 역할에 맞는 모드로 자동 이동

**4단계: 빠른 접근 기능 (선택)**
- 홈 화면에 자주 사용하는 기능 바로가기

---

## 결론

**이 방안은 좋은 선택입니다!** 특히:
- ✅ 명확한 역할 구분
- ✅ 사용자 제어
- ✅ 구현 단순성

**개선 사항:**
- 마지막 선택 기억 기능 추가 (필수)
- 알림 클릭 시 자동 모드 선택
- 필요 시 빠른 접근 기능

**다음 단계:**
1. 홈 화면에 역할 선택 버튼 추가
2. SharedPreferences로 마지막 선택 저장
3. SubjectModeScreen, GuardianModeScreen 생성
4. 알림 클릭 시 자동 모드 선택 로직 추가
